<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>HTML面试 | 所有不能打倒我的，都将使我更强大！</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="HTML 面试题DOCTYPE 的作用是什么  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来 进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏 览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。  标准模式与兼容模式的区别 标准模式的渲染方式和">
<meta property="og:type" content="article">
<meta property="og:title" content="HTML面试">
<meta property="og:url" content="http://example.com/2021/03/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="所有不能打倒我的，都将使我更强大！">
<meta property="og:description" content="HTML 面试题DOCTYPE 的作用是什么  声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来 进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏 览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。  标准模式与兼容模式的区别 标准模式的渲染方式和">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-24T10:14:03.108Z">
<meta property="article:modified_time" content="2021-04-23T02:06:05.271Z">
<meta property="article:author" content="mu_lou_mu_di">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="所有不能打倒我的，都将使我更强大！" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">所有不能打倒我的，都将使我更强大！</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-前端面试" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" class="article-date">
  <time datetime="2021-03-24T10:14:03.108Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HTML面试
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTML-面试题"><a href="#HTML-面试题" class="headerlink" title="HTML 面试题"></a>HTML 面试题</h1><h3 id="DOCTYPE-的作用是什么"><a href="#DOCTYPE-的作用是什么" class="headerlink" title="DOCTYPE 的作用是什么"></a>DOCTYPE 的作用是什么</h3><ul>
<li><!DOCTYPE> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来 进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏 览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。</li>
</ul>
<h3 id="标准模式与兼容模式的区别"><a href="#标准模式与兼容模式的区别" class="headerlink" title="标准模式与兼容模式的区别"></a>标准模式与兼容模式的区别</h3><ul>
<li>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行的</li>
<li>兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
<h3 id="DTD-介绍"><a href="#DTD-介绍" class="headerlink" title="DTD 介绍"></a>DTD 介绍</h3><ul>
<li>DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元 素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。</li>
<li>DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</li>
</ul>
<h3 id="4，空元素定义"><a href="#4，空元素定义" class="headerlink" title="4，空元素定义"></a>4，空元素定义</h3><ul>
<li>标签内没有内容的 HTML 标签被称为空标签，空标签是在开始标签中关闭的。</li>
<li>常见的空标签有 br,hr,img,input,link,meta。</li>
</ul>
<h3 id="5-HTML5-为什么只需要写-，而不需要引入-DTD？"><a href="#5-HTML5-为什么只需要写-，而不需要引入-DTD？" class="headerlink" title="5, HTML5 为什么只需要写  ，而不需要引入 DTD？"></a>5, HTML5 为什么只需要写 <!DOCTYPE HTML> ，而不需要引入 DTD？</h3><ul>
<li>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运 行）。</li>
<li>而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</li>
</ul>
<h3 id="6-SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#6-SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="6, SGML 、 HTML 、XML 和 XHTML 的区别？"></a>6, SGML 、 HTML 、XML 和 XHTML 的区别？</h3><ul>
<li>SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</li>
<li>HTML 是超文本标记语言，主要是用于规定怎么显示网页。</li>
<li>XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多， 而 HTML 的标签都是固定的而且数量有限。</li>
<li>XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</li>
</ul>
<h3 id="7-css-中-calc-support-media-各自的含义及用法"><a href="#7-css-中-calc-support-media-各自的含义及用法" class="headerlink" title="7, css 中 calc.support,media 各自的含义及用法"></a>7, css 中 calc.support,media 各自的含义及用法</h3><ul>
<li>@support 主要是用于检测浏览器是否支持 CSS 的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。</li>
<li>calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-“, “*“, “/“ 运算；</li>
<li>@media 查询，你可以针对不同的媒体类型定义不同的样式。</li>
</ul>
<h3 id="8，css-水平、垂直居中的-4-种写法"><a href="#8，css-水平、垂直居中的-4-种写法" class="headerlink" title="8，css 水平、垂直居中的 4 种写法"></a>8，css 水平、垂直居中的 4 种写法</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ul>
<li>行内元素: text-align: center</li>
<li>块级元素: margin: 0 auto</li>
<li>position:absolute +left:50%+ transform:translateX(-50%)</li>
<li>display:flex + justify-content: center</li>
</ul>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ul>
<li>设置 line-height 等于 height</li>
<li>position：absolute +top:50%+ transform:translateY(-50%)</li>
<li>display:flex + align-items: center</li>
<li>display:table+display:table-cell + vertical-align: middle;</li>
</ul>
<h3 id="1rem、1em、1vh、1px-各自代表的含义？"><a href="#1rem、1em、1vh、1px-各自代表的含义？" class="headerlink" title="1rem、1em、1vh、1px 各自代表的含义？"></a>1rem、1em、1vh、1px 各自代表的含义？</h3><h6 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h6><p>rem 是全部的长度都相对于根元素<html>元素。通常做法是给 html 元素设置一个字体大小，然后其他元素的长度单位就为 rem。</p>
<h6 id="em"><a href="#em" class="headerlink" title="em"></a>em</h6><ul>
<li>子元素字体大小的 em 是相对于父元素字体大小</li>
<li>元素的 width/height/padding/margin 用 em 的话是相对于该元素的 font-size</li>
</ul>
<h6 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw/vh"></a>vw/vh</h6><p>全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。</p>
<h6 id="px"><a href="#px" class="headerlink" title="px"></a>px</h6><p>px 像素（Pixel）。相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。<br>一般电脑的分辨率有{1920<em>1024}等不同的分辨率<br>1920</em>1024 前者是屏幕宽度总共有 1920 个像素,后者则是高度为 1024 个像素</p>
<h3 id="画一条-0-5px-的直线"><a href="#画一条-0-5px-的直线" class="headerlink" title="画一条 0.5px 的直线"></a>画一条 0.5px 的直线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height: 1px;</span><br><span class="line">transform: scale(0.5);</span><br></pre></td></tr></table></figure>

<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>盒模型的组成，由里向外 content,padding,border,margin.</p>
<p>在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度</p>
<p>在标准的盒子模型中，width 指 content 部分的宽度</p>
<h6 id="box-sizing-的使用"><a href="#box-sizing-的使用" class="headerlink" title="box-sizing 的使用"></a>box-sizing 的使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: content-box 是W3C盒子模型</span><br><span class="line">box-sizing: border-box 是IE盒子模型</span><br></pre></td></tr></table></figure>

<p>box-sizing 的默认属性是 content-box</p>
<h3 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.a&#123;</span><br><span class="line">            width: 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            border-width: 100px;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            border-color: transparent #0099CC transparent transparent;</span><br><span class="line">            transform: rotate(90deg); &#x2F;*顺时针旋转90°*&#x2F;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;a&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="清除浮动的几种方式及原理"><a href="#清除浮动的几种方式及原理" class="headerlink" title="清除浮动的几种方式及原理"></a>清除浮动的几种方式及原理</h3><ul>
<li>::after /<br> / clear:both</li>
<li>创建父级 BFC(overflow:hidden)</li>
<li>父级设置高度</li>
</ul>
<h6 id="BFC-（块级格式化上下文），是一个独立的渲染区域，让处于-BFC-内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。"><a href="#BFC-（块级格式化上下文），是一个独立的渲染区域，让处于-BFC-内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。" class="headerlink" title="BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。"></a>BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</h6><h6 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件:"></a>触发条件:</h6><ul>
<li>根元素</li>
<li>position: absolute/fixed</li>
<li>display: inline-block / table</li>
<li>float 元素</li>
<li>ovevflow !== visible</li>
</ul>
<h6 id="规则"><a href="#规则" class="headerlink" title="规则:"></a>规则:</h6><ul>
<li>属于同一个 BFC 的两个相邻 Box 垂直排列</li>
<li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>
<li>BFC 的区域不会与 float 的元素区域重叠</li>
<li>计算 BFC 的高度时，浮动子元素也参与计算</li>
<li>文字层不会被浮动层覆盖，环绕于周围</li>
</ul>
<h3 id="标签的用法"><a href="#标签的用法" class="headerlink" title="标签的用法"></a><label>标签的用法</h3><p>label 标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验</p>
<h3 id="遍历-A-节点的父节点下的所有子节点"><a href="#遍历-A-节点的父节点下的所有子节点" class="headerlink" title="遍历 A 节点的父节点下的所有子节点"></a>遍历 A 节点的父节点下的所有子节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var b&#x3D;document.getElementById(&quot;a&quot;).parentNode.children;</span><br><span class="line">    console.log(b)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="用-js-递归的方式写-1-到-100-求和"><a href="#用-js-递归的方式写-1-到-100-求和" class="headerlink" title="用 js 递归的方式写 1 到 100 求和"></a>用 js 递归的方式写 1 到 100 求和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(num1,num2)&#123;</span><br><span class="line">	var num &#x3D; num1+num2;</span><br><span class="line">        if(num2+1&gt;100)&#123;</span><br><span class="line">	 return num;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">	  return add(num,num2+1)</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">var sum &#x3D;add(1,2);</span><br></pre></td></tr></table></figure>

<h3 id="页面渲染-html-的过程"><a href="#页面渲染-html-的过程" class="headerlink" title="页面渲染 html 的过程"></a>页面渲染 html 的过程</h3><p>1.浏览器解析 html 源码，然后创建一个 DOM 树。并行请求 css/image/js 在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM 树的根节点就是 documentElement，对应的是 html 标签。</p>
<p>2.浏览器解析 CSS 代码，计算出最终的样式数据。构建 CSSOM 树。对 CSS 代码中非法的语法它会直接忽略掉。解析 CSS 的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html 中的 style。</p>
<p>3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和 DOM 树有点像，但是是有区别的。</p>
<p>DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的 css 属性。</p>
<p>4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p>
<p>以上四个步骤并不是一次性顺序完成的。如果 DOM 或者 CSSOM 被修改，以上过程会被重复执行。实际上，CSS 和 JavaScript 往往会多次修改 DOM 或者 CSSOM。</p>
<h3 id="说一下-CORS"><a href="#说一下-CORS" class="headerlink" title="说一下 CORS"></a>说一下 CORS</h3><p>CORS 是一种新标准，支持同源通信，也支持跨域通信。fetch 是实现 CORS 通信的</p>
<h3 id="如何中断-ajax-请求"><a href="#如何中断-ajax-请求" class="headerlink" title="如何中断 ajax 请求"></a>如何中断 ajax 请求</h3><p>一种是设置超时时间让 ajax 自动断开，另一种是手动停止 ajax 请求，其核心是调用 XML 对象的 abort 方法，ajax.abort()</p>
<h3 id="说一下事件代理"><a href="#说一下事件代理" class="headerlink" title="说一下事件代理"></a>说一下事件代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ulEl.addEventListener(&#39;click&#39;, function(e)&#123;</span><br><span class="line">    var target &#x3D; event.target || event.srcElement;</span><br><span class="line">    if(!!target &amp;&amp; target.nodeName.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;LI&quot;)&#123;</span><br><span class="line">        console.log(target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<h3 id="target、currentTarget-的区别"><a href="#target、currentTarget-的区别" class="headerlink" title="target、currentTarget 的区别"></a>target、currentTarget 的区别</h3><p>currentTarget 当前所绑定事件的元素</p>
<p>target 当前被点击的元素</p>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。<br>微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick 等等）。<br>宏任务中的事件放在 callback queue 中，由事件触发线程维护；微任务的事件放在微任务队列中，由 js 引擎线程维护。</p>
<h3 id="继承的几种方式及优缺点"><a href="#继承的几种方式及优缺点" class="headerlink" title="继承的几种方式及优缺点"></a>继承的几种方式及优缺点</h3><p>1,借用构造函数继承，使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上<br>2,原型继承，将子对象的 prototype 指向父对象的一个实例<br>3,组合继承</p>
<h6 id="原型链继承的缺点"><a href="#原型链继承的缺点" class="headerlink" title="原型链继承的缺点"></a>原型链继承的缺点</h6><p>字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p>
<h6 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h6><p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。</p>
<h6 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h6><p>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的实质是因为函数嵌套而形成的作用域链</p>
<p>闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包</p>
<h3 id="什么是会话-cookie-什么是持久-cookie"><a href="#什么是会话-cookie-什么是持久-cookie" class="headerlink" title="什么是会话 cookie,什么是持久 cookie"></a>什么是会话 cookie,什么是持久 cookie</h3><p>cookie 是服务器返回的，指定了 expire time（有效期）的是持久 cookie,没有指定的是会话 cookie</p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[&#39;12&#39;,&#39;32&#39;,&#39;89&#39;,&#39;12&#39;,&#39;12&#39;,&#39;78&#39;,&#39;12&#39;,&#39;32&#39;];</span><br><span class="line">    &#x2F;&#x2F; 最简单数组去重法</span><br><span class="line">    function unique1(array)&#123;</span><br><span class="line">        var n &#x3D; []; &#x2F;&#x2F;一个新的临时数组</span><br><span class="line">        for(var i &#x3D; 0; i &lt; array.length; i++)&#123; &#x2F;&#x2F;遍历当前数组</span><br><span class="line">            if (n.indexOf(array[i]) &#x3D;&#x3D; -1)</span><br><span class="line">                n.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    arr&#x3D;unique1(arr);</span><br><span class="line">    &#x2F;&#x2F; 速度最快， 占空间最多（空间换时间）</span><br><span class="line">    function unique2(array)&#123;</span><br><span class="line">        var n &#x3D; &#123;&#125;, r &#x3D; [], type;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            type &#x3D; typeof array[i];</span><br><span class="line">            if (!n[array[i]]) &#123;</span><br><span class="line">                n[array[i]] &#x3D; [type];</span><br><span class="line">                r.push(array[i]);</span><br><span class="line">            &#125; else if (n[array[i]].indexOf(type) &lt; 0) &#123;</span><br><span class="line">                n[array[i]].push(type);</span><br><span class="line">                r.push(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;数组下标判断法</span><br><span class="line">    function unique3(array)&#123;</span><br><span class="line">        var n &#x3D; [array[0]]; &#x2F;&#x2F;结果数组</span><br><span class="line">        for(var i &#x3D; 1; i &lt; array.length; i++) &#123; &#x2F;&#x2F;从第二项开始遍历</span><br><span class="line">            if (array.indexOf(array[i]) &#x3D;&#x3D; i)</span><br><span class="line">                n.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">es6方法数组去重</span><br><span class="line">arr&#x3D;[...new Set(arr)];</span><br><span class="line">es6方法数组去重，第二种方法</span><br><span class="line">function dedupe(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));       &#x2F;&#x2F;Array.from()能把set结构转换为数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get、post-的区别"><a href="#get、post-的区别" class="headerlink" title="get、post 的区别"></a>get、post 的区别</h3><p>1.get 传参方式是通过地址栏 URL 传递，是可以直接看到 get 传递的参数，post 传参方式参数 URL 不可见，get 把请求的数据在 URL 后通过？连接，通过&amp;进行参数分割。psot 将参数存放在 HTTP 的包体内</p>
<p>2.get 传递数据是通过 URL 进行传递，对传递的数据长度是受到 URL 大小的限制，URL 最大长度是 2048 个字符。post 没有长度限制</p>
<p>3.get 后退不会有影响，post 后退会重新进行提交</p>
<p>4.get 请求可以被缓存，post 不可以被缓存</p>
<p>5.get 请求只 URL 编码，post 支持多种编码方式</p>
<p>6.get 请求的记录会留在历史记录中，post 请求不会留在历史记录</p>
<p>7.get 只支持 ASCII 字符，post 没有字符类型限制</p>
<h3 id="你所知道的-http-的响应码及含义"><a href="#你所知道的-http-的响应码及含义" class="headerlink" title="你所知道的 http 的响应码及含义"></a>你所知道的 http 的响应码及含义</h3><p>1xx(临时响应)</p>
<p>100: 请求者应当继续提出请求。</p>
<p>101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。</p>
<p>2xx(成功)</p>
<p>200：正确的请求返回正确的结果</p>
<p>201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。</p>
<p>202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。</p>
<p>3xx(已重定向)</p>
<p>300：请求成功，但结果有多种选择。</p>
<p>301：请求成功，但是资源被永久转移。</p>
<p>303：使用 GET 来访问新的地址来获取资源。</p>
<p>304：请求的资源并没有被修改过</p>
<p>4xx(请求错误)</p>
<p>400：请求出现错误，比如请求头不对等。</p>
<p>401：没有提供认证信息。请求的时候没有带上 Token 等。</p>
<p>402：为以后需要所保留的状态码。</p>
<p>403：请求的资源不允许访问。就是说没有权限。</p>
<p>404：请求的内容不存在。</p>
<p>5xx(服务器错误)</p>
<p>500：服务器错误。</p>
<p>501：请求还没有被实现。</p>
<h3 id="css-中-link-和-import-的区别"><a href="#css-中-link-和-import-的区别" class="headerlink" title="css 中 link 和@import 的区别"></a>css 中 link 和@import 的区别</h3><h5 id="1，从属关系区别"><a href="#1，从属关系区别" class="headerlink" title="1，从属关系区别"></a>1，从属关系区别</h5><p>@import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、ｒｅｌ连接属性等。</p>
<h5 id="２，加载顺序区别"><a href="#２，加载顺序区别" class="headerlink" title="２，加载顺序区别"></a>２，加载顺序区别</h5><p>加载页面时，<code>link</code>标签引入的 CSS 被同时加载；<code>@import</code>引入的 CSS 将在页面加载完毕后被加载。</p>
<h5 id="3-兼容性区别"><a href="#3-兼容性区别" class="headerlink" title="3.兼容性区别"></a>3.兼容性区别</h5><p><code>@import</code>是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；<code>link</code>标签作为 HTML 元素，不存在兼容性问题。</p>
<h5 id="4-DOM-可控性区别"><a href="#4-DOM-可控性区别" class="headerlink" title="4.DOM 可控性区别"></a>4.DOM 可控性区别</h5><p>可以通过 JS 操作 DOM ，插入<code>link</code>标签来改变样式；由于 DOM 方法是基于文档的，无法使用<code>@import</code>的方式插入样式。</p>
<h3 id="const-var-let的区别"><a href="#const-var-let的区别" class="headerlink" title="　const　var　let的区别"></a>　<strong>const</strong>　<strong>var</strong>　<strong>let</strong>的区别</h3><p>１，<strong>const 定义的变量不可以修改，而且必须初始化</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">// const b;//错误，必须初始化</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函数外const定义b：&quot;</span> + b); <span class="comment">//有输出值</span></span><br><span class="line"><span class="comment">// b = 5;</span></span><br><span class="line"><span class="comment">// console.log(&#x27;函数外修改const定义b：&#x27; + b);//无法输出</span></span><br></pre></td></tr></table></figure>

<p>２，<strong>var 定义的变量可以修改，如果不初始化会输出 undefined，不会报错。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// var a;//不会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函数外var定义a：&quot;</span> + a); <span class="comment">//可以输出a=1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数内var定义a：&quot;</span> + a); <span class="comment">//可以输出a=4</span></span><br><span class="line">&#125;</span><br><span class="line">change();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函数调用后var定义a为函数内部修改值：&quot;</span> + a); <span class="comment">//可以输出a=4</span></span><br></pre></td></tr></table></figure>

<p><strong>3.let 是块级作用域，函数内部使用 let 定义后，对函数外部无影响。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函数外let定义c：&quot;</span> + c); <span class="comment">//输出c=3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> c = <span class="number">6</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;函数内let定义c：&quot;</span> + c); <span class="comment">//输出c=6</span></span><br><span class="line">&#125;</span><br><span class="line">change();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;函数调用后let定义c不受函数内部定义影响：&quot;</span> + c); <span class="comment">//输出c=3</span></span><br></pre></td></tr></table></figure>

<h3 id="css选择器和css选择器权重"><a href="#css选择器和css选择器权重" class="headerlink" title="ｃｓｓ选择器和ｃｓｓ选择器权重"></a>ｃｓｓ选择器和ｃｓｓ选择器权重</h3><h4 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h4><p>１、类别选择器</p>
<p>类选择器根据类名来选择，前面以”.”来标志。如：**.wrap**<br>这的类名在 HTML 中 class 属性定义。</p>
<p>２、标签选择器</p>
<p>一个 HTML 页面是有很多不同的标签组成，而标签选择器，则是决定哪些标签<br>采用相应的 CSS 样式。如：<strong>div</strong></p>
<p>３、ID 选择器</p>
<p>ID 选择器可以为标有特定 ID 的 HTML 元素指定特定的样式。 根据元素 ID 来选择元素，具有唯一性，这意味着同一 id 在同一文档页面中只能出现一次，这样就可以选定某个特定的元素进行编辑。如：**#name**</p>
<p>４、后代选择器</p>
<p>后代选择器也称为包含选择器，用来选择特定元素或元素组的后代，将父元素的选择放在前面，对需要选择的后代元素的选择放在后面，中间加一个空格分开（可逐级选择，也可跳级选择）。结合之前的类选择、标签选择、ID 选择，一层一层的选中特定的元素。<br>注意：后代选择器选择的不一定是子元素，只要是父元素下满足条件的元素都会被选择上。</p>
<p>５、子选择器</p>
<p>子选择器仅是指它的直接后代，或者你可以理解为作用于子元素的第一个后代。通过“&gt;”进行选择。必须一层一层选择到需要的地方。</p>
<p>６、伪类选择器</p>
<p>有时候还会需要用文档以外的其他条件来应用元素的样式，比如鼠标悬停等。这时候我们就需要用到伪类了。以下是链接应用的伪类定义。</p>
<table>
<thead>
<tr>
<th align="center">伪类选择器</th>
<th align="center">效果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hover</td>
<td align="center">匹配鼠标悬停其上的元素</td>
</tr>
<tr>
<td align="center">visited</td>
<td align="center">匹配所有已被点击的连接</td>
</tr>
<tr>
<td align="center">link</td>
<td align="center">匹配所有未被点击的链接</td>
</tr>
<tr>
<td align="center">active</td>
<td align="center">匹配鼠标已经在其上按下 但是还没有释放的元素</td>
</tr>
</tbody></table>
<p>7、通用选择器</p>
<p>通用选择器用*来表示。选择 HTML 中所有的部分。<br>一般用于初始化设定。</p>
<p>8、群组选择器</p>
<p>当几个元素样式属性一样时，可以共同调用一个声明，元素之间用逗号分隔。</p>
<h4 id="CSS-权重"><a href="#CSS-权重" class="headerlink" title="CSS 权重"></a>CSS 权重</h4><p>一个元素可以通过不同的方式被选择。但这些选择出现冲突该如何处理？<br>通过不同的方法选择一个元素会有不同的权重，如果权重大，就依照权重大的。如果权重一样大，就选择定义在后面的元素定义。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">权重</th>
</tr>
</thead>
<tbody><tr>
<td align="center">！import</td>
<td align="center">无穷</td>
</tr>
<tr>
<td align="center">行间样式</td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">id</td>
<td align="center">100</td>
</tr>
<tr>
<td align="center">class/属性选择器/伪类</td>
<td align="center">10</td>
</tr>
<tr>
<td align="center">标签选择器</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">通配符</td>
<td align="center">0</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/" data-id="ckmnai7bk000048v19iqk10j1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/23/IIS%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          IIS文件服务器
        
      </div>
    </a>
  
  
    <a href="/2020/12/23/JS%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JS的深拷贝与浅拷贝</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/23/disableHostCheck/">disableHostCheck</a>
          </li>
        
          <li>
            <a href="/2021/04/23/CRC8%E9%AA%8C%E6%A0%A1%E7%AE%97%E6%B3%95/">CRC8校验算法</a>
          </li>
        
          <li>
            <a href="/2021/04/23/IIS%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/">IIS文件服务器</a>
          </li>
        
          <li>
            <a href="/2021/03/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">HTML面试</a>
          </li>
        
          <li>
            <a href="/2020/12/23/JS%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/">JS的深拷贝与浅拷贝</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 mu_lou_mu_di<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>