

<!DOCTYPE html>
<html lang="en" color-mode=light>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>前端面试题 - 所有不能打倒我的，都将使我更强大！</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  
  <meta name="description" content="HTML 面试题DOCTYPE 的作用是什么
 声明一..."> 
  
  <meta name="author" content="leesin"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_onl0g0h21np.css">

  

  
  
  
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        onlyPost: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: false,
        alipay: '',
        wechat: ''
      },
      motto: {
        api: '',
        default: '所有不能打倒我的，都将使我更强大！'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.2.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">前端面试题</div>
  <div class="right">
    
      <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
    
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">前端面试题</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>November 02, 2020</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>7461</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h1 id="HTML-面试题"><a href="#HTML-面试题" class="headerlink" title="HTML 面试题"></a>HTML 面试题</h1><h3 id="DOCTYPE-的作用是什么"><a href="#DOCTYPE-的作用是什么" class="headerlink" title="DOCTYPE 的作用是什么"></a>DOCTYPE 的作用是什么</h3><ul>
<li><!DOCTYPE> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以标准模式来 进行文档解析，否则就以兼容模式进行解析。在标准模式下，浏览器的解析规则都是按照最新的标准进行解析的。而在兼容模式下，浏 览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站的正确访问。</li>
</ul>
<h3 id="标准模式与兼容模式的区别"><a href="#标准模式与兼容模式的区别" class="headerlink" title="标准模式与兼容模式的区别"></a>标准模式与兼容模式的区别</h3><ul>
<li>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行的</li>
<li>兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li>
</ul>
<h3 id="DTD-介绍"><a href="#DTD-介绍" class="headerlink" title="DTD 介绍"></a>DTD 介绍</h3><ul>
<li>DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元 素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。</li>
<li>DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</li>
</ul>
<h3 id="4，空元素定义"><a href="#4，空元素定义" class="headerlink" title="4，空元素定义"></a>4，空元素定义</h3><ul>
<li>标签内没有内容的 HTML 标签被称为空标签，空标签是在开始标签中关闭的。</li>
<li>常见的空标签有 br,hr,img,input,link,meta。</li>
</ul>
<h3 id="5-HTML5-为什么只需要写-，而不需要引入-DTD？"><a href="#5-HTML5-为什么只需要写-，而不需要引入-DTD？" class="headerlink" title="5, HTML5 为什么只需要写  ，而不需要引入 DTD？"></a>5, HTML5 为什么只需要写 <!DOCTYPE HTML> ，而不需要引入 DTD？</h3><ul>
<li>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运 行）。</li>
<li>而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</li>
</ul>
<h3 id="6-SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#6-SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="6, SGML 、 HTML 、XML 和 XHTML 的区别？"></a>6, SGML 、 HTML 、XML 和 XHTML 的区别？</h3><ul>
<li>SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</li>
<li>HTML 是超文本标记语言，主要是用于规定怎么显示网页。</li>
<li>XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多， 而 HTML 的标签都是固定的而且数量有限。</li>
<li>XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</li>
</ul>
<h3 id="7-css-中-calc-support-media-各自的含义及用法"><a href="#7-css-中-calc-support-media-各自的含义及用法" class="headerlink" title="7, css 中 calc.support,media 各自的含义及用法"></a>7, css 中 calc.support,media 各自的含义及用法</h3><ul>
<li>@support 主要是用于检测浏览器是否支持 CSS 的某个属性，其实就是条件判断，如果支持某个属性，你可以写一套样式，如果不支持某个属性，你也可以提供另外一套样式作为替补。</li>
<li>calc() 函数用于动态计算长度值。 calc()函数支持 “+”, “-“, “*“, “/“ 运算；</li>
<li>@media 查询，你可以针对不同的媒体类型定义不同的样式。</li>
</ul>
<h3 id="8，css-水平、垂直居中的-4-种写法"><a href="#8，css-水平、垂直居中的-4-种写法" class="headerlink" title="8，css 水平、垂直居中的 4 种写法"></a>8，css 水平、垂直居中的 4 种写法</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ul>
<li>行内元素: text-align: center</li>
<li>块级元素: margin: 0 auto</li>
<li>position:absolute +left:50%+ transform:translateX(-50%)</li>
<li>display:flex + justify-content: center</li>
</ul>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ul>
<li>设置 line-height 等于 height</li>
<li>position：absolute +top:50%+ transform:translateY(-50%)</li>
<li>display:flex + align-items: center</li>
<li>display:table+display:table-cell + vertical-align: middle;</li>
</ul>
<h3 id="1rem、1em、1vh、1px-各自代表的含义？"><a href="#1rem、1em、1vh、1px-各自代表的含义？" class="headerlink" title="1rem、1em、1vh、1px 各自代表的含义？"></a>1rem、1em、1vh、1px 各自代表的含义？</h3><h6 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h6><p>rem 是全部的长度都相对于根元素<html>元素。通常做法是给 html 元素设置一个字体大小，然后其他元素的长度单位就为 rem。</p>
<h6 id="em"><a href="#em" class="headerlink" title="em"></a>em</h6><ul>
<li>子元素字体大小的 em 是相对于父元素字体大小</li>
<li>元素的 width/height/padding/margin 用 em 的话是相对于该元素的 font-size</li>
</ul>
<h6 id="vw-vh"><a href="#vw-vh" class="headerlink" title="vw/vh"></a>vw/vh</h6><p>全称是 Viewport Width 和 Viewport Height，视窗的宽度和高度，相当于 屏幕宽度和高度的 1%，不过，处理宽度的时候%单位更合适，处理高度的 话 vh 单位更好。</p>
<h6 id="px"><a href="#px" class="headerlink" title="px"></a>px</h6><p>px 像素（Pixel）。相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。<br>一般电脑的分辨率有{1920<em>1024}等不同的分辨率<br>1920</em>1024 前者是屏幕宽度总共有 1920 个像素,后者则是高度为 1024 个像素</p>
<h3 id="画一条-0-5px-的直线"><a href="#画一条-0-5px-的直线" class="headerlink" title="画一条 0.5px 的直线"></a>画一条 0.5px 的直线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height: 1px;</span><br><span class="line">transform: scale(0.5);</span><br></pre></td></tr></table></figure>

<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>盒模型的组成，由里向外 content,padding,border,margin.</p>
<p>在 IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度</p>
<p>在标准的盒子模型中，width 指 content 部分的宽度</p>
<h6 id="box-sizing-的使用"><a href="#box-sizing-的使用" class="headerlink" title="box-sizing 的使用"></a>box-sizing 的使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box-sizing: content-box 是W3C盒子模型</span><br><span class="line">box-sizing: border-box 是IE盒子模型</span><br></pre></td></tr></table></figure>

<p>box-sizing 的默认属性是 content-box</p>
<h3 id="画一个三角形"><a href="#画一个三角形" class="headerlink" title="画一个三角形"></a>画一个三角形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.a&#123;</span><br><span class="line">            width: 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            border-width: 100px;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            border-color: transparent #0099CC transparent transparent;</span><br><span class="line">            transform: rotate(90deg); &#x2F;*顺时针旋转90°*&#x2F;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class&#x3D;&quot;a&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="清除浮动的几种方式及原理"><a href="#清除浮动的几种方式及原理" class="headerlink" title="清除浮动的几种方式及原理"></a>清除浮动的几种方式及原理</h3><ul>
<li>::after /<br> / clear:both</li>
<li>创建父级 BFC(overflow:hidden)</li>
<li>父级设置高度</li>
</ul>
<h6 id="BFC-（块级格式化上下文），是一个独立的渲染区域，让处于-BFC-内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。"><a href="#BFC-（块级格式化上下文），是一个独立的渲染区域，让处于-BFC-内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。" class="headerlink" title="BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。"></a>BFC （块级格式化上下文），是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</h6><h6 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件:"></a>触发条件:</h6><ul>
<li>根元素</li>
<li>position: absolute/fixed</li>
<li>display: inline-block / table</li>
<li>float 元素</li>
<li>ovevflow !== visible</li>
</ul>
<h6 id="规则"><a href="#规则" class="headerlink" title="规则:"></a>规则:</h6><ul>
<li>属于同一个 BFC 的两个相邻 Box 垂直排列</li>
<li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li>
<li>BFC 的区域不会与 float 的元素区域重叠</li>
<li>计算 BFC 的高度时，浮动子元素也参与计算</li>
<li>文字层不会被浮动层覆盖，环绕于周围</li>
</ul>
<h3 id="标签的用法"><a href="#标签的用法" class="headerlink" title="标签的用法"></a><label>标签的用法</h3><p>label 标签主要是方便鼠标点击使用，扩大可点击的范围，增强用户操作体验</p>
<h3 id="遍历-A-节点的父节点下的所有子节点"><a href="#遍历-A-节点的父节点下的所有子节点" class="headerlink" title="遍历 A 节点的父节点下的所有子节点"></a>遍历 A 节点的父节点下的所有子节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var b&#x3D;document.getElementById(&quot;a&quot;).parentNode.children;</span><br><span class="line">    console.log(b)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="用-js-递归的方式写-1-到-100-求和"><a href="#用-js-递归的方式写-1-到-100-求和" class="headerlink" title="用 js 递归的方式写 1 到 100 求和"></a>用 js 递归的方式写 1 到 100 求和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(num1,num2)&#123;</span><br><span class="line">	var num &#x3D; num1+num2;</span><br><span class="line">        if(num2+1&gt;100)&#123;</span><br><span class="line">	 return num;</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">	  return add(num,num2+1)</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line">var sum &#x3D;add(1,2);</span><br></pre></td></tr></table></figure>

<h3 id="页面渲染-html-的过程"><a href="#页面渲染-html-的过程" class="headerlink" title="页面渲染 html 的过程"></a>页面渲染 html 的过程</h3><p>1.浏览器解析 html 源码，然后创建一个 DOM 树。并行请求 css/image/js 在 DOM 树中，每一个 HTML 标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。DOM 树的根节点就是 documentElement，对应的是 html 标签。</p>
<p>2.浏览器解析 CSS 代码，计算出最终的样式数据。构建 CSSOM 树。对 CSS 代码中非法的语法它会直接忽略掉。解析 CSS 的时候会按照如下顺序来定义优先级：浏览器默认设置 &lt; 用户设置 &lt; 外链样式 &lt; 内联样式 &lt; html 中的 style。</p>
<p>3.DOM Tree + CSSOM –&gt; 渲染树（rendering tree）。渲染树和 DOM 树有点像，但是是有区别的。</p>
<p>DOM 树完全和 html 标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如 head、display:none 的元素等。而且一大段文本中的每一个行在渲染树中都是独立的一个节点。渲染树中的每一个节点都存储有对应的 css 属性。</p>
<p>4.一旦渲染树创建好了，浏览器就可以根据渲染树直接把页面绘制到屏幕上。</p>
<p>以上四个步骤并不是一次性顺序完成的。如果 DOM 或者 CSSOM 被修改，以上过程会被重复执行。实际上，CSS 和 JavaScript 往往会多次修改 DOM 或者 CSSOM。</p>
<h3 id="说一下-CORS"><a href="#说一下-CORS" class="headerlink" title="说一下 CORS"></a>说一下 CORS</h3><p>CORS 是一种新标准，支持同源通信，也支持跨域通信。fetch 是实现 CORS 通信的</p>
<h3 id="如何中断-ajax-请求"><a href="#如何中断-ajax-请求" class="headerlink" title="如何中断 ajax 请求"></a>如何中断 ajax 请求</h3><p>一种是设置超时时间让 ajax 自动断开，另一种是手动停止 ajax 请求，其核心是调用 XML 对象的 abort 方法，ajax.abort()</p>
<h3 id="说一下事件代理"><a href="#说一下事件代理" class="headerlink" title="说一下事件代理"></a>说一下事件代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ulEl.addEventListener(&#39;click&#39;, function(e)&#123;</span><br><span class="line">    var target &#x3D; event.target || event.srcElement;</span><br><span class="line">    if(!!target &amp;&amp; target.nodeName.toUpperCase() &#x3D;&#x3D;&#x3D; &quot;LI&quot;)&#123;</span><br><span class="line">        console.log(target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<h3 id="target、currentTarget-的区别"><a href="#target、currentTarget-的区别" class="headerlink" title="target、currentTarget 的区别"></a>target、currentTarget 的区别</h3><p>currentTarget 当前所绑定事件的元素</p>
<p>target 当前被点击的元素</p>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><p>宏任务：当前调用栈中执行的任务称为宏任务。（主代码快，定时器等等）。<br>微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick 等等）。<br>宏任务中的事件放在 callback queue 中，由事件触发线程维护；微任务的事件放在微任务队列中，由 js 引擎线程维护。</p>
<h3 id="继承的几种方式及优缺点"><a href="#继承的几种方式及优缺点" class="headerlink" title="继承的几种方式及优缺点"></a>继承的几种方式及优缺点</h3><p>1,借用构造函数继承，使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上<br>2,原型继承，将子对象的 prototype 指向父对象的一个实例<br>3,组合继承</p>
<h6 id="原型链继承的缺点"><a href="#原型链继承的缺点" class="headerlink" title="原型链继承的缺点"></a>原型链继承的缺点</h6><p>字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p>
<h6 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h6><p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。</p>
<h6 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h6><p>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的实质是因为函数嵌套而形成的作用域链</p>
<p>闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包</p>
<h3 id="什么是会话-cookie-什么是持久-cookie"><a href="#什么是会话-cookie-什么是持久-cookie" class="headerlink" title="什么是会话 cookie,什么是持久 cookie"></a>什么是会话 cookie,什么是持久 cookie</h3><p>cookie 是服务器返回的，指定了 expire time（有效期）的是持久 cookie,没有指定的是会话 cookie</p>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[&#39;12&#39;,&#39;32&#39;,&#39;89&#39;,&#39;12&#39;,&#39;12&#39;,&#39;78&#39;,&#39;12&#39;,&#39;32&#39;];</span><br><span class="line">    &#x2F;&#x2F; 最简单数组去重法</span><br><span class="line">    function unique1(array)&#123;</span><br><span class="line">        var n &#x3D; []; &#x2F;&#x2F;一个新的临时数组</span><br><span class="line">        for(var i &#x3D; 0; i &lt; array.length; i++)&#123; &#x2F;&#x2F;遍历当前数组</span><br><span class="line">            if (n.indexOf(array[i]) &#x3D;&#x3D; -1)</span><br><span class="line">                n.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line">    arr&#x3D;unique1(arr);</span><br><span class="line">    &#x2F;&#x2F; 速度最快， 占空间最多（空间换时间）</span><br><span class="line">    function unique2(array)&#123;</span><br><span class="line">        var n &#x3D; &#123;&#125;, r &#x3D; [], type;</span><br><span class="line">        for (var i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            type &#x3D; typeof array[i];</span><br><span class="line">            if (!n[array[i]]) &#123;</span><br><span class="line">                n[array[i]] &#x3D; [type];</span><br><span class="line">                r.push(array[i]);</span><br><span class="line">            &#125; else if (n[array[i]].indexOf(type) &lt; 0) &#123;</span><br><span class="line">                n[array[i]].push(type);</span><br><span class="line">                r.push(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;数组下标判断法</span><br><span class="line">    function unique3(array)&#123;</span><br><span class="line">        var n &#x3D; [array[0]]; &#x2F;&#x2F;结果数组</span><br><span class="line">        for(var i &#x3D; 1; i &lt; array.length; i++) &#123; &#x2F;&#x2F;从第二项开始遍历</span><br><span class="line">            if (array.indexOf(array[i]) &#x3D;&#x3D; i)</span><br><span class="line">                n.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">es6方法数组去重</span><br><span class="line">arr&#x3D;[...new Set(arr)];</span><br><span class="line">es6方法数组去重，第二种方法</span><br><span class="line">function dedupe(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));       &#x2F;&#x2F;Array.from()能把set结构转换为数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="get、post-的区别"><a href="#get、post-的区别" class="headerlink" title="get、post 的区别"></a>get、post 的区别</h3><p>1.get 传参方式是通过地址栏 URL 传递，是可以直接看到 get 传递的参数，post 传参方式参数 URL 不可见，get 把请求的数据在 URL 后通过？连接，通过&amp;进行参数分割。psot 将参数存放在 HTTP 的包体内</p>
<p>2.get 传递数据是通过 URL 进行传递，对传递的数据长度是受到 URL 大小的限制，URL 最大长度是 2048 个字符。post 没有长度限制</p>
<p>3.get 后退不会有影响，post 后退会重新进行提交</p>
<p>4.get 请求可以被缓存，post 不可以被缓存</p>
<p>5.get 请求只 URL 编码，post 支持多种编码方式</p>
<p>6.get 请求的记录会留在历史记录中，post 请求不会留在历史记录</p>
<p>7.get 只支持 ASCII 字符，post 没有字符类型限制</p>
<h3 id="你所知道的-http-的响应码及含义"><a href="#你所知道的-http-的响应码及含义" class="headerlink" title="你所知道的 http 的响应码及含义"></a>你所知道的 http 的响应码及含义</h3><p>1xx(临时响应)</p>
<p>100: 请求者应当继续提出请求。</p>
<p>101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。</p>
<p>2xx(成功)</p>
<p>200：正确的请求返回正确的结果</p>
<p>201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。</p>
<p>202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。</p>
<p>3xx(已重定向)</p>
<p>300：请求成功，但结果有多种选择。</p>
<p>301：请求成功，但是资源被永久转移。</p>
<p>303：使用 GET 来访问新的地址来获取资源。</p>
<p>304：请求的资源并没有被修改过</p>
<p>4xx(请求错误)</p>
<p>400：请求出现错误，比如请求头不对等。</p>
<p>401：没有提供认证信息。请求的时候没有带上 Token 等。</p>
<p>402：为以后需要所保留的状态码。</p>
<p>403：请求的资源不允许访问。就是说没有权限。</p>
<p>404：请求的内容不存在。</p>
<p>5xx(服务器错误)</p>
<p>500：服务器错误。</p>
<p>501：请求还没有被实现。</p>
<p>持续更新中··· 嘤嘤嘤</p>

      </section>
      <section class="extra">
        
        <ul class="copyright">
  
  <li><strong>本文作者：</strong>leesin</li>
  <li><strong>本文链接：</strong><a href="http://example.com/2020/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">http://example.com/2020/11/02/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/index.html</a></li>
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
        
        
        
        
<nav class="nav">
  
  
    <a href="/2020/10/27/Symbol%E7%9A%84%E7%89%B9%E6%80%A7/">JavaScript的Symbol特性<i class="iconfont iconright"></i></a>
  
</nav>

      </section>
      
      <section class="comments">
  
  <div class="btn" id="comments-btn">查看评论</div>
  
  
</section>
      
    </section>
  </div>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=894519210 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://www.instagram.com/izhaoo/ " target="_blank" onMouseOver="this.style.color= '#DA2E76'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconinstagram "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/izhaoo " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="mailto:izhaoo@163.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/izhaoo/hexo-theme-zhaoo">zhaoo</a></p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>